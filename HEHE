    -- Zeltrix Hub On Top
    -- Zeltrix Hub Rivals+
    
local user_input_service = game:GetService("UserInputService")
local players_service = game:GetService("Players")
local workspace_service = game:GetService("Workspace")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local LocalPlayer = Players.LocalPlayer
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local Humanoid = Character:WaitForChild("Humanoid")
local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")


local LocalPlayer = Players.LocalPlayer
local CurrentCamera = workspace.CurrentCamera
local WorldToViewportPoint = CurrentCamera.WorldToViewportPoint

local flying = false
local flySpeed = 100
local maxFlySpeed = 1000
local speedIncrement = 0.4
local originalGravity = workspace.Gravity
local flyKey = Enum.KeyCode.F -- Default keybind for flying

local LocalPlayer = Players.LocalPlayer
local Noclip = nil
local Clip = nil
local noclipKey = Enum.KeyCode.N -- Default keybind for noclip
local isNoclipEnabled = false

-- Aimbot variables
local isAimbotActive = false
local aimbotKey = Enum.UserInputType.MouseButton2
local targetPart = "Head"
local enableStickyAim = true
local enablePrediction = true
local predictionStrengthX = 0.2
local predictionStrengthY = 0.2
local fovSize = 200
local lockedTarget = nil
local smoothness = 0.4


    
    local visuals_enabled = false
    local show_boxes_enabled = false
    local show_tracers_enabled = false
    local show_names_enabled = false
    local show_skeleton_enabled = false
    local show_view_line_enabled = false

    local aimbot_enabled = false  
    local aimbot_keybind = Enum.UserInputType.MouseButton2
    local aimbot_sticky_aim_enabled = true
    local aimbot_prediction_enabled = true
    local aimbot_prediction_strength_x = 0.1
    local aimbot_prediction_strength_y = 0.1
    local aimbot_aim_part = "Head"

    local aimbot_smoothness_enabled = true
    local aimbot_smoothness = 0.3
    

    local aimbot_fov_size = 200
   

    

    local locked_target = nil

    local players_service = game:GetService("Players")
    local run_service = game:GetService("RunService")
    local user_input_service = game:GetService("UserInputService")
    local visual_elements = {}
    local tp_behind_offset = 0
    local tp_behind_height = 6
    local teleporting = false
    local speed_multiplier = 0
    local speed_modifier_enabled = false






function noclip()
    Clip = false
    local function Nocl()
        if Clip == false and LocalPlayer.Character ~= nil then
            for _, v in pairs(LocalPlayer.Character:GetDescendants()) do
                if v:IsA('BasePart') and v.CanCollide then
                    v.CanCollide = false
                end
            end
        end
        RunService.Stepped:Wait() 
    end
    Noclip = RunService.Stepped:Connect(Nocl)
end

function clip()
    if Noclip then Noclip:Disconnect() end
    Clip = true
end

local function toggleNoclip()
    isNoclipEnabled = not isNoclipEnabled
    if isNoclipEnabled then
        noclip()
        print("Noclip enabled.")
    else
        clip()
        print("Noclip disabled.")
    end
end



-- Reinitialize when the character resets
LocalPlayer.CharacterAdded:Connect(function(newCharacter)
    Character = newCharacter
    Humanoid = Character:WaitForChild("Humanoid")
    HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")
end)

local function randomizeValue(value, range)
    return value + (value * (math.random(-range, range) / 100))
end

local function fly()
    while flying do
        local MoveDirection = Vector3.new()
        local cameraCFrame = workspace.CurrentCamera.CFrame

        MoveDirection = MoveDirection + (UserInputService:IsKeyDown(Enum.KeyCode.W) and cameraCFrame.LookVector or Vector3.new())
        MoveDirection = MoveDirection - (UserInputService:IsKeyDown(Enum.KeyCode.S) and cameraCFrame.LookVector or Vector3.new())
        MoveDirection = MoveDirection - (UserInputService:IsKeyDown(Enum.KeyCode.A) and cameraCFrame.RightVector or Vector3.new())
        MoveDirection = MoveDirection + (UserInputService:IsKeyDown(Enum.KeyCode.D) and cameraCFrame.RightVector or Vector3.new())
        MoveDirection = MoveDirection + (UserInputService:IsKeyDown(Enum.KeyCode.Space) and Vector3.new(0, 1, 0) or Vector3.new())
        MoveDirection = MoveDirection - (UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) and Vector3.new(0, 1, 0) or Vector3.new())

        if MoveDirection.Magnitude > 0 then
            flySpeed = math.min(flySpeed + speedIncrement, maxFlySpeed)
            MoveDirection = MoveDirection.Unit * math.min(randomizeValue(flySpeed, 10), maxFlySpeed)
            HumanoidRootPart.Velocity = MoveDirection * 0.5
        else
            HumanoidRootPart.Velocity = Vector3.new(0, 0, 0)
        end

        RunService.RenderStepped:Wait()
    end
end


    function init_visuals(player)
        if not visuals_enabled then
            return
        end
        if player == players_service.LocalPlayer then
            return
        end

        local character = player.Character or player.CharacterAdded:Wait()
        local humanoid_root_part = character:WaitForChild("HumanoidRootPart")

        local box_visual = Drawing.new("Square")
        box_visual.Color = Color3.fromRGB(255, 255, 255)
        box_visual.Thickness = 2
        box_visual.Transparency = 1
        box_visual.Filled = false

        local tracer_visual = Drawing.new("Line")
        tracer_visual.Color = Color3.fromRGB(255, 255, 255)
        tracer_visual.Thickness = 1
        tracer_visual.Transparency = 1

        local name_visual = Drawing.new("Text")
        name_visual.Text = player.Name
        name_visual.Color = Color3.fromRGB(255, 255, 255)
        name_visual.Size = 20
        name_visual.Center = true
        name_visual.Outline = true
        name_visual.Transparency = 1

        local skeleton_lines = {}
        for i = 1, 6 do
            local line = Drawing.new("Line")
            line.Color = Color3.fromRGB(255, 255, 255)
            line.Thickness = 2.5
            line.Transparency = 1
            table.insert(skeleton_lines, line)
        end

        local view_line = Drawing.new("Line")
        view_line.Color = Color3.fromRGB(255, 255, 255)
        view_line.Thickness = 2.5
        view_line.Transparency = 1

        visual_elements[player] = {
            box = box_visual,
            tracer = tracer_visual,
            name = name_visual,
            skeleton = skeleton_lines,
            view_line = view_line
        }

        local function update_visuals()
            if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
                box_visual.Visible = false
                tracer_visual.Visible = false
                name_visual.Visible = false
                for _, line in pairs(skeleton_lines) do
                    line.Visible = false
                end
                view_line.Visible = false
                return
            end
        
            if not visuals_enabled then
                box_visual.Visible = false
                tracer_visual.Visible = false
                name_visual.Visible = false
                for _, line in pairs(skeleton_lines) do
                    line.Visible = false
                end
                view_line.Visible = false
                return
            end
        
            local hrp_position, on_screen = workspace.CurrentCamera:WorldToViewportPoint(humanoid_root_part.Position)
            if on_screen then
                local top = workspace.CurrentCamera:WorldToViewportPoint(humanoid_root_part.Position + Vector3.new(0, 3, 0))
                local bottom = workspace.CurrentCamera:WorldToViewportPoint(humanoid_root_part.Position - Vector3.new(0, 3, 0))
                local size = Vector2.new(math.abs(top.X - bottom.X) * 1.5, math.abs(top.Y - bottom.Y) * 1.5)
        
                if show_boxes_enabled then
                    box_visual.Size = size
                    box_visual.Position = Vector2.new(hrp_position.X - size.X / 2, hrp_position.Y - size.Y / 2)
                    box_visual.Visible = true
                else
                    box_visual.Visible = false
                end
        
                if show_tracers_enabled then
                    tracer_visual.From = Vector2.new(workspace.CurrentCamera.ViewportSize.X / 2, workspace.CurrentCamera.ViewportSize.Y)
                    tracer_visual.To = Vector2.new(hrp_position.X, hrp_position.Y)
                    tracer_visual.Visible = true
                else
                    tracer_visual.Visible = false
                end
        
                if show_names_enabled then
                    name_visual.Position = Vector2.new(hrp_position.X, hrp_position.Y - size.Y / 2 - 20)
                    name_visual.Visible = true
                else
                    name_visual.Visible = false
                end
        
                if show_view_line_enabled and player.Character:FindFirstChild("Head") then
                    local head = player.Character:FindFirstChild("Head")
                    local head_pos = workspace.CurrentCamera:WorldToViewportPoint(head.Position)
                    local forward_vector = player.Character.HumanoidRootPart.CFrame.LookVector * 2
                    local view_point = head.Position + forward_vector
                    local view_pos = workspace.CurrentCamera:WorldToViewportPoint(view_point)
        
                    view_line.From = Vector2.new(head_pos.X, head_pos.Y)
                    view_line.To = Vector2.new(view_pos.X, view_pos.Y)
                    view_line.Visible = true
                else
                    view_line.Visible = false
                end
        
                if show_skeleton_enabled and player.Character then
                    local parts = {
                        head = player.Character:FindFirstChild("Head"),
                        left_arm = player.Character:FindFirstChild("LeftUpperArm"),
                        right_arm = player.Character:FindFirstChild("RightUpperArm"),
                        left_leg = player.Character:FindFirstChild("LeftUpperLeg"),
                        right_leg = player.Character:FindFirstChild("RightUpperLeg"),
                        torso = player.Character:FindFirstChild("Torso") or player.Character:FindFirstChild("UpperTorso")
                    }
        
                    if parts.head and parts.torso then
                        local head_pos = workspace.CurrentCamera:WorldToViewportPoint(parts.head.Position)
                        local torso_pos = workspace.CurrentCamera:WorldToViewportPoint(parts.torso.Position)
        
                        skeleton_lines[1].From = Vector2.new(head_pos.X, head_pos.Y)
                        skeleton_lines[1].To = Vector2.new(torso_pos.X, torso_pos.Y)
                        skeleton_lines[1].Visible = true
        
                        if parts.left_arm then
                            local left_arm_pos = workspace.CurrentCamera:WorldToViewportPoint(parts.left_arm.Position)
                            skeleton_lines[2].From = Vector2.new(torso_pos.X, torso_pos.Y)
                            skeleton_lines[2].To = Vector2.new(left_arm_pos.X, left_arm_pos.Y)
                            skeleton_lines[2].Visible = true
                        else
                            skeleton_lines[2].Visible = false
                        end
        
                        if parts.right_arm then
                            local right_arm_pos = workspace.CurrentCamera:WorldToViewportPoint(parts.right_arm.Position)
                            skeleton_lines[3].From = Vector2.new(torso_pos.X, torso_pos.Y)
                            skeleton_lines[3].To = Vector2.new(right_arm_pos.X, right_arm_pos.Y)
                            skeleton_lines[3].Visible = true
                        else
                            skeleton_lines[3].Visible = false
                        end
        
                        if parts.left_leg then
                            local left_leg_pos = workspace.CurrentCamera:WorldToViewportPoint(parts.left_leg.Position)
                            skeleton_lines[4].From = Vector2.new(torso_pos.X, torso_pos.Y)
                            skeleton_lines[4].To = Vector2.new(left_leg_pos.X, left_leg_pos.Y)
                            skeleton_lines[4].Visible = true
                        else
                            skeleton_lines[4].Visible = false
                        end
        
                        if parts.right_leg then
                            local right_leg_pos = workspace.CurrentCamera:WorldToViewportPoint(parts.right_leg.Position)
                            skeleton_lines[5].From = Vector2.new(torso_pos.X, torso_pos.Y)
                            skeleton_lines[5].To = Vector2.new(right_leg_pos.X, right_leg_pos.Y)
                            skeleton_lines[5].Visible = true
                        else
                            skeleton_lines[5].Visible = false
                        end
                    end
                else
                    for _, line in pairs(skeleton_lines) do
                        line.Visible = false
                    end
                end
            else
                box_visual.Visible = false
                tracer_visual.Visible = false
                name_visual.Visible = false
                for _, line in pairs(skeleton_lines) do
                    line.Visible = false
                end
                view_line.Visible = false
            end
        end
        

        run_service.RenderStepped:Connect(update_visuals)
    end

    function remove_visuals(player)
        if visual_elements[player] then
            visual_elements[player].box:Remove()
            visual_elements[player].tracer:Remove()
            visual_elements[player].name:Remove()
            visual_elements[player] = nil
        end
    end

    function add_visuals(player)
        player.CharacterAdded:Connect(
            function()
                init_visuals(player)
            end
        )
        player.CharacterRemoving:Connect(
            function()
                remove_visuals(player)
            end
        )
        if player.Character then
            init_visuals(player)
        end
    end

    players_service.PlayerAdded:Connect(add_visuals)

    for _, player in pairs(players_service:GetPlayers()) do
        add_visuals(player)
    end

    function toggle_visuals(state)
        visuals_enabled = state
        if not state then
            for _, player in pairs(players_service:GetPlayers()) do
                remove_visuals(player)
            end
        else
            for _, player in pairs(players_service:GetPlayers()) do
                if player.Character then
                    init_visuals(player)
                end
            end
        end
    end

    function aimbot()
        if not aimbot_enabled or not aimbot_keybind then
            return
        end

        if aimbot_keybind == Enum.UserInputType.MouseButton2 then
            if not user_input_service:IsMouseButtonPressed(aimbot_keybind) then
                locked_target = nil
                return
            end
        else
            if not user_input_service:IsKeyDown(aimbot_keybind) then
                locked_target = nil
                return
            end
        end


        local camera = workspace.CurrentCamera
        local mouse = players_service.LocalPlayer:GetMouse()

        if locked_target and aimbot_sticky_aim_enabled then
            if locked_target.Character and locked_target.Character:FindFirstChild(aimbot_aim_part) then
                local part = locked_target.Character[aimbot_aim_part]
                local predicted_position = part.Position
                if aimbot_prediction_enabled then
                    local velocity = locked_target.Character.HumanoidRootPart.Velocity
                    predicted_position =
                        part.Position +
                        Vector3.new(
                            velocity.X * aimbot_prediction_strength_x * 0.1,
                            velocity.Y * aimbot_prediction_strength_y * 0.1,
                            0
                        )
                end
                local screen_pos = camera:WorldToViewportPoint(predicted_position)
                local target = Vector2.new(screen_pos.X, screen_pos.Y)
                local screen_center = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2)
                local move = target - screen_center

                if aimbot_smoothness_enabled then
                    local move_step = move / (aimbot_smoothness + 1)
                    mousemoverel(move_step.X, move_step.Y)
                else
                    mousemoverel(move.X, move.Y)
                end
                return
            else
                locked_target = nil
            end
        end

        local closest_player = nil
        local closest_distance = aimbot_fov_size

        for _, player in pairs(players_service:GetPlayers()) do
            if
                player ~= players_service.LocalPlayer and player.Character and
                    player.Character:FindFirstChild(aimbot_aim_part)
             then
                local part = player.Character[aimbot_aim_part]
                local predicted_position = part.Position
                if aimbot_prediction_enabled then
                    local velocity = player.Character.HumanoidRootPart.Velocity
                    predicted_position =
                        part.Position +
                        Vector3.new(
                            velocity.X * aimbot_prediction_strength_x * 0.1,
                            velocity.Y * aimbot_prediction_strength_y * 0.1,
                            0
                        )
                end
                local screen_pos, on_screen = camera:WorldToViewportPoint(predicted_position)
                if on_screen then
                    local distance =
                        (Vector2.new(screen_pos.X, screen_pos.Y) -
                        Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2)).magnitude
                    if distance < closest_distance then
                        closest_distance = distance
                        closest_player = player
                    end
                end
            end
        end

        if closest_player then
            locked_target = closest_player
            local part = closest_player.Character[aimbot_aim_part]
            local predicted_position = part.Position
            if aimbot_prediction_enabled then
                local velocity = closest_player.Character.HumanoidRootPart.Velocity
                predicted_position =
                    part.Position +
                    Vector3.new(
                        velocity.X * aimbot_prediction_strength_x * 0.1,
                        velocity.Y * aimbot_prediction_strength_y * 0.1,
                        0
                    )
            end
            local screen_pos = camera:WorldToViewportPoint(predicted_position)
            local target = Vector2.new(screen_pos.X, screen_pos.Y)
            local screen_center = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2)
            local move = target - screen_center

            if aimbot_smoothness_enabled then
                local move_step = move / (aimbot_smoothness + 1)
                mousemoverel(move_step.X, move_step.Y)
            else
                mousemoverel(move.X, move.Y)
            end
        end
    end

    run_service.RenderStepped:Connect(aimbot)

    local fov_circle = Drawing.new("Circle")
    fov_circle.Color = Color3.fromRGB(255, 255, 255)
    fov_circle.Thickness = 1
    fov_circle.Transparency = 1
    fov_circle.Filled = false

    function update_fov_circle()
        if show_fov then
            local camera = workspace.CurrentCamera
            local mouse_pos = user_input_service:GetMouseLocation()
            fov_circle.Radius = aimbot_fov_size
            fov_circle.Position = Vector2.new(mouse_pos.X, mouse_pos.Y)
            fov_circle.Visible = true
        else
            fov_circle.Visible = false
        end
    end

    run_service.RenderStepped:Connect(update_fov_circle)

    function string_to_enum(string)
        local newstring = string:gsub("Enum.KeyCode.","")
        return Enum.KeyCode[newstring]
    end 

    local function save_config(path)
        
        local config = {
            visuals_enabled = visuals_enabled,
            show_boxes_enabled = show_boxes_enabled,
            show_tracers_enabled = show_tracers_enabled,
            show_names_enabled = show_names_enabled,
            show_skeleton_enabled = show_skeleton_enabled,
            show_view_line_enabled = show_view_line_enabled,
            aimbot_enabled = aimbot_enabled,
            aimbot_fov_size = aimbot_fov_size,
            aimbot_aim_part = aimbot_aim_part,
            aimbot_smoothness = aimbot_smoothness,
            show_fov = show_fov,
            aimbot_keybind = tostring(aimbot_keybind),  
            aimbot_smoothness_enabled = aimbot_smoothness_enabled,
            aimbot_prediction_enabled = aimbot_prediction_enabled,
            aimbot_prediction_strength_x = aimbot_prediction_strength_x,
            aimbot_prediction_strength_y = aimbot_prediction_strength_y,
            aimbot_sticky_aim_enabled = aimbot_sticky_aim_enabled
        }
        local config_string = game:GetService("HttpService"):JSONEncode(config)
        writefile(path, config_string)
    end

    local function load_config(path)
        if isfile(path) then
            local config_string = readfile(path)
            local config = game:GetService("HttpService"):JSONDecode(config_string)
            visuals_enabled = config.visuals_enabled
            show_boxes_enabled = config.show_boxes_enabled
            show_tracers_enabled = config.show_tracers_enabled
            show_names_enabled = config.show_names_enabled
            show_skeleton_enabled = config.show_skeleton_enabled
            show_view_line_enabled = config.show_view_line_enabled
            aimbot_enabled = config.aimbot_enabled
            aimbot_fov_size = config.aimbot_fov_size
            aimbot_aim_part = config.aimbot_aim_part
            aimbot_smoothness = config.aimbot_smoothness
            show_fov = config.show_fov
            aimbot_keybind = string_to_enum(config.aimbot_keybind)
            aimbot_smoothness_enabled = config.aimbot_smoothness_enabled
            aimbot_prediction_enabled = config.aimbot_prediction_enabled
            aimbot_prediction_strength_x = config.aimbot_prediction_strength_x
            aimbot_prediction_strength_y = config.aimbot_prediction_strength_y
            aimbot_sticky_aim_enabled = config.aimbot_sticky_aim_enabled
            toggle_visuals(visuals_enabled)
        end
    end

    local function loop_behind(target_player)
        teleporting = true
        local player = players_service.LocalPlayer
    
        while teleporting do
            local target_character = target_player.Character
            local target_humanoid_root_part = target_character and target_character:FindFirstChild("HumanoidRootPart")
            local player_character = player.Character
            local player_humanoid_root_part = player_character and player_character:FindFirstChild("HumanoidRootPart")
    
            if player_humanoid_root_part and target_humanoid_root_part then
                local target_cframe = target_humanoid_root_part.CFrame
                local target_look_vector = target_cframe.LookVector
                local target_position = target_cframe.Position
                local new_position =
                    target_position - (target_look_vector * tp_behind_offset) + Vector3.new(0, tp_behind_height, 0)
                player_humanoid_root_part.CFrame = CFrame.new(new_position, new_position + target_look_vector)
            end
    
            task.wait()
        end
    end



















local function getPredictedPosition(player)
    local characterPart = player.Character[targetPart]
    local predictedPosition = characterPart.Position
    if enablePrediction then
        local velocity = player.Character.HumanoidRootPart.Velocity
        predictedPosition = characterPart.Position + Vector3.new(
            velocity.X * predictionStrengthX * 0.1,
            velocity.Y * predictionStrengthY * 0.1,
            0
        )
    end
    return predictedPosition
end

local function activateZeltrixAimbot()
    if not isAimbotActive then return end
    local camera = workspace_service.CurrentCamera

    if not user_input_service:IsMouseButtonPressed(aimbotKey) then
        lockedTarget = nil
        return
    end

    if lockedTarget and enableStickyAim then
        if lockedTarget.Character and lockedTarget.Character:FindFirstChild(targetPart) then
            local predictedPosition = getPredictedPosition(lockedTarget)
            local screenPos = camera:WorldToViewportPoint(predictedPosition)
            local targetPos = Vector2.new(screenPos.X, screenPos.Y)
            local screenCenter = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2)
            local move = targetPos - screenCenter

            local moveStep = move / smoothness
            mousemoverel(moveStep.X, moveStep.Y)
            return
        else
            lockedTarget = nil
        end
    end

    local closestPlayer = nil
    local closestDistance = fovSize
    for _, player in pairs(players_service:GetPlayers()) do
        if player ~= players_service.LocalPlayer and player.Character and player.Character:FindFirstChild(targetPart) then
            local predictedPosition = getPredictedPosition(player)
            local screenPos, onScreen = camera:WorldToViewportPoint(predictedPosition)
            if onScreen then
                local distance = (Vector2.new(screenPos.X, screenPos.Y) - Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2)).magnitude
                if distance < closestDistance then
                    closestDistance = distance
                    closestPlayer = player
                end
            end
        end
    end

    if closestPlayer then
        lockedTarget = closestPlayer
        local predictedPosition = getPredictedPosition(closestPlayer)
        local screenPos = camera:WorldToViewportPoint(predictedPosition)
        local targetPos = Vector2.new(screenPos.X, screenPos.Y)
        local screenCenter = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2)
        local move = targetPos - screenCenter

        local moveStep = move / smoothness
        mousemoverel(moveStep.X, moveStep.Y)
    end
end

local function getPredictedPosition(player)
    local characterPart = player.Character[targetPart]
    local predictedPosition = characterPart.Position
    if enablePrediction then
        local velocity = player.Character.HumanoidRootPart.Velocity
        predictedPosition = characterPart.Position + Vector3.new(
            velocity.X * predictionStrengthX * 0.1,
            velocity.Y * predictionStrengthY * 0.1,
            0
        )
    end
    return predictedPosition
end





local function activateZeltrixAimbot()
    if not isAimbotActive then return end
    local camera = workspace_service.CurrentCamera

    if not user_input_service:IsMouseButtonPressed(aimbotKey) then
        lockedTarget = nil
        return
    end

    if lockedTarget and enableStickyAim then
        if lockedTarget.Character and lockedTarget.Character:FindFirstChild(targetPart) then
            local predictedPosition = getPredictedPosition(lockedTarget)
            local screenPos = camera:WorldToViewportPoint(predictedPosition)
            local targetPos = Vector2.new(screenPos.X, screenPos.Y)
            local screenCenter = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2)
            local move = targetPos - screenCenter

            local moveStep = move / smoothness
            mousemoverel(moveStep.X, moveStep.Y)
            return
        else
            lockedTarget = nil
        end
    end

    local closestPlayer = nil
    local closestDistance = fovSize
    for _, player in pairs(players_service:GetPlayers()) do
        if player ~= players_service.LocalPlayer and player.Character and player.Character:FindFirstChild(targetPart) then
            local predictedPosition = getPredictedPosition(player)
            local screenPos, onScreen = camera:WorldToViewportPoint(predictedPosition)
            if onScreen then
                local distance = (Vector2.new(screenPos.X, screenPos.Y) - Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2)).magnitude
                if distance < closestDistance then
                    closestDistance = distance
                    closestPlayer = player
                end
            end
        end
    end

    if closestPlayer then
        lockedTarget = closestPlayer
        local predictedPosition = getPredictedPosition(closestPlayer)
        local screenPos = camera:WorldToViewportPoint(predictedPosition)
        local targetPos = Vector2.new(screenPos.X, screenPos.Y)
        local screenCenter = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2)
        local move = targetPos - screenCenter

        local moveStep = move / smoothness
        mousemoverel(moveStep.X, moveStep.Y)
    end
end




local HeadOff = Vector3.new(0, 0.5, 0)
local LegOff = Vector3.new(0, 3, 0)

local HealthText = Drawing.new("Text")
HealthText.Size = 18
HealthText.Color = Color3.fromRGB(255, 255, 255)
HealthText.Transparency = 1
HealthText.Visible = false

local healthTextEnabled = false  

local function createESP(Player)
    local BoxOutline = Drawing.new("Square")
    BoxOutline.Visible = false
    BoxOutline.Color = Color3.fromRGB(0, 0, 0)
    BoxOutline.Thickness = 3
    BoxOutline.Transparency = 1

    local Box = Drawing.new("Square")
    Box.Visible = false
    Box.Color = Color3.fromRGB(255, 255, 255)
    Box.Thickness = 1
    Box.Transparency = 1

    local HealthBarOutline = Drawing.new("Square")
    HealthBarOutline.Thickness = 3
    HealthBarOutline.Filled = false
    HealthBarOutline.Color = Color3.new(0, 0, 0)
    HealthBarOutline.Transparency = 1
    HealthBarOutline.Visible = false

    local HealthBar = Drawing.new("Square")
    HealthBar.Thickness = 1
    HealthBar.Filled = true
    HealthBar.Transparency = 1
    HealthBar.Visible = false

    local function BoxESP()
        RunService.RenderStepped:Connect(function()
            if healthTextEnabled then
                if Player.Character and Player.Character:FindFirstChild("Humanoid") and Player.Character:FindFirstChild("HumanoidRootPart") and Player ~= LocalPlayer then
                    local humanoid = Player.Character.Humanoid
                    if humanoid.Health > 0 then
                        local RootPart = Player.Character.HumanoidRootPart
                        local Head = Player.Character.Head

                        local RootPos, OnScreen = CurrentCamera:WorldToViewportPoint(RootPart.Position)
                        local HeadPos = CurrentCamera:WorldToViewportPoint(Head.Position + HeadOff)
                        local LegPos = CurrentCamera:WorldToViewportPoint(RootPart.Position - LegOff)

                        if OnScreen then
                            BoxOutline.Size = Vector2.new(1000 / RootPos.Z, HeadPos.Y - LegPos.Y)
                            BoxOutline.Position = Vector2.new(RootPos.X - BoxOutline.Size.X / 2, RootPos.Y - BoxOutline.Size.Y / 2)
                            BoxOutline.Visible = true

                            Box.Size = Vector2.new(1000 / RootPos.Z, HeadPos.Y - LegPos.Y)
                            Box.Position = Vector2.new(RootPos.X - Box.Size.X / 2, RootPos.Y - Box.Size.Y / 2)
                            Box.Visible = true

                            HealthBarOutline.Size = Vector2.new(2, HeadPos.Y - LegPos.Y)
                            HealthBarOutline.Position = BoxOutline.Position - Vector2.new(6, 0)
                            HealthBarOutline.Visible = true

                            local healthPercentage = humanoid.Health / humanoid.MaxHealth
                            HealthBar.Size = Vector2.new(2, (HeadPos.Y - LegPos.Y) * healthPercentage)
                            HealthBar.Position = Vector2.new(Box.Position.X - 6, Box.Position.Y + (1 / HealthBar.Size.Y))
                            HealthBar.Color = Color3.fromRGB(255 * (1 - healthPercentage), 255 * healthPercentage, 0)
                            HealthBar.Visible = true

                            HealthText.Text = math.floor(healthPercentage * 100) .. "%"
                            HealthText.Position = Vector2.new(RootPos.X, RootPos.Y - (HeadPos.Y - LegPos.Y) / 2 - 20)
                            HealthText.Visible = true
                        else
                            BoxOutline.Visible = false
                            Box.Visible = false
                            HealthBarOutline.Visible = false
                            HealthBar.Visible = false
                            HealthText.Visible = false
                        end
                    else
                        BoxOutline.Visible = false
                        Box.Visible = false
                        HealthBarOutline.Visible = false
                        HealthBar.Visible = false
                        HealthText.Visible = false
                    end
                else
                    BoxOutline.Visible = false
                    Box.Visible = false
                    HealthBarOutline.Visible = false
                    HealthBar.Visible = false
                    HealthText.Visible = false
                end
            else
                BoxOutline.Visible = false
                Box.Visible = false
                HealthBarOutline.Visible = false
                HealthBar.Visible = false
                HealthText.Visible = false
            end
        end)
    end
    coroutine.wrap(BoxESP)()
end

for _, Player in ipairs(Players:GetChildren()) do
    if healthTextEnabled then
        createESP(Player)
    end
end

Players.PlayerAdded:Connect(function(Player)
    if healthTextEnabled then
        createESP(Player)
    end
end)














local lib = loadstring(game:HttpGet("https://raw.githubusercontent.com/LunarClientScript/Lunar/refs/heads/main/its%20so%20rizz"))()
local win = lib:Window("Zeltrix Aimbot", Color3.fromRGB(44, 120, 224), Enum.KeyCode.RightShift)
local tab = win:Tab("Aimbot Settings")
local visuals_tab = win:Tab("Visuals")
local player_tab = win:Tab("Players")

tab:Toggle("Quick Aimbot No Mods", false, function(state)
    isAimbotActive = state
    if isAimbotActive then

    else

    end
end)


tab:Label("Different Aimbots")

tab:Toggle("Enable Aimbot", false, function(state)
    aimbot_enabled = state
    if aimbott_enabled then
    else
    end
end)

tab:Toggle("Enable Sticky Aim", false, function(value)
    aimbot_sticky_aim_enabled = value
end)

tab:Toggle("Enable Prediction", false, function(value)
    aimbot_prediction_enabled = value
end)

tab:Slider("Smoothness", 0.3, 10, 0.3, function(value)
    aimbot_smoothness = value
end)

tab:Toggle("Show FOV", false, function(state)
    show_fov = state
    if show_fov then
    else
    end
end)

tab:Slider("FOV Size", 0, 200, 50, function(value)
    aimbot_fov_size = value
end)

tab:Slider("Smoothness Level", 0, 10, 5, function(value)
    aimbot_smoothness_enabled = (value > 0) 
    aimbot_smoothness = value
end)

tab:Slider("Prediction Strength X", 0, 10, 0, function(value)
    aimbot_prediction_strength_x = value
end)

tab:Slider("Prediction Strength Y", 0, 10, 0, function(value)
    aimbot_prediction_strength_y = value
end)

tab:Dropdown("Aim Part", {"Head", "Torso", "Legs"}, function(value)
    aimbot_aim_part = value
end)

visuals_tab:Toggle("Enable Visuals", false, function(value)
    visuals_enabled = value
    toggle_visuals(value)
end)

visuals_tab:Toggle("Show Boxes", false, function(value)
    show_boxes_enabled = value
end)

visuals_tab:Toggle("Show Tracers", false, function(value)
    show_tracers_enabled = value
end)

visuals_tab:Toggle("Show Names", false, function(value)
    show_names_enabled = value
end)

visuals_tab:Toggle("Show Skeletons", false, function(value)
    show_skeleton_enabled = value
end)

tab:Label("Box With HealthBAR")


visuals_tab:Toggle("Box Health Bar", false, function(enabled)
    healthTextEnabled = enabled
    if enabled then
        for _, Player in ipairs(Players:GetChildren()) do
            createESP(Player)
        end
        Players.PlayerAdded:Connect(function(Player)
            createESP(Player)
        end)
    else
        for _, Player in ipairs(Players:GetChildren()) do
            BoxOutline.Visible = false
            Box.Visible = false
            HealthBarOutline.Visible = false
            HealthBar.Visible = false
            HealthText.Visible = false
        end
        Players.PlayerAdded:Connect(function(Player)
            BoxOutline.Visible = false
            Box.Visible = false
            HealthBarOutline.Visible = false
            HealthBar.Visible = false
            HealthText.Visible = false
        end)
    end
end)



player_tab:Toggle("Enable Speed", false, function(state)
    speed_modifier_enabled = state
    if speed_modifier_enabled then
        repeat
            local local_player = players_service.LocalPlayer
            if local_player and local_player.Character and local_player.Character:FindFirstChild("HumanoidRootPart") then
                local humanoid_root_part = local_player.Character.HumanoidRootPart
                local humanoid = local_player.Character:FindFirstChild("Humanoid")
                if humanoid then
                    humanoid_root_part.CFrame = humanoid_root_part.CFrame + humanoid.MoveDirection * speed_multiplier
                end
            end
            game:GetService("RunService").Stepped:Wait()
        until not speed_modifier_enabled
    end
end)

player_tab:Slider("Walkspeed", 0, 10, 0, function(value)
    speed_multiplier = value
end)

player_tab:Toggle("Noclip Toggle", false, function(state)
    isNoclipEnabled = state
    if isNoclipEnabled then
        noclip()
    else
        clip()
    end
end)

player_tab:Bind("Noclip Keybind", noclipKey, function()
    toggleNoclip()
end)


player_tab:Toggle("Fly Toggle", false, function(state)
    flying = state
    if flying then
        workspace.Gravity = 0
        fly()
    else
        flySpeed = 100
        HumanoidRootPart.Velocity = Vector3.new(0, 0, 0)
        workspace.Gravity = originalGravity
    end
end)

player_tab:Bind("Fly Keybind", flyKey, function()
   flyKey = key
end)

game:GetService("RunService").Heartbeat:Connect(activateZeltrixAimbot)
